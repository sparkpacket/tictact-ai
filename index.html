<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TicTac-AI (Adaptive)</title>
<style>
  body {
    font-family: monospace;
    background: #000;
    color: #0f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(3, 100px);
    grid-template-rows: repeat(3, 100px);
    gap: 5px;
  }
  .cell {
    width: 100px;
    height: 100px;
    background: #111;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    cursor: pointer;
    transition: background 0.2s;
  }
  .cell:hover { background: #222; }
  #status { margin-top: 20px; }
</style>
</head>
<body>
<h1>TicTac-AI (Adaptive)</h1>
<div id="board"></div>
<div id="status"></div>
<script>
const boardEl = document.getElementById("board");
const statusEl = document.getElementById("status");
let board = Array(9).fill(null);
let gameOver = false;

// Load learning data from localStorage
let aiMemory = JSON.parse(localStorage.getItem("aiMemory")) || {};

// Utility functions
function checkWinner(b) {
  const wins = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  for (let [a,b1,c] of wins)
    if (b[a] && b[a]===b[b1] && b[a]===b[c]) return b[a];
  if (b.every(x => x)) return "draw";
  return null;
}

function boardKey(b) {
  return b.map(x => x || "_").join("");
}

function storeGameResult(history, result) {
  for (let state of history) {
    aiMemory[state] = aiMemory[state] || {wins:0, losses:0, draws:0};
    if (result === "O") aiMemory[state].wins++;
    else if (result === "X") aiMemory[state].losses++;
    else aiMemory[state].draws++;
  }
  localStorage.setItem("aiMemory", JSON.stringify(aiMemory));
}

function clone(b){return b.slice();}

function minimax(b, isMaximizing) {
  let result = checkWinner(b);
  if (result === "O") return {score: 10};
  if (result === "X") return {score: -10};
  if (result === "draw") return {score: 0};

  let best = {score: isMaximizing ? -Infinity : Infinity, index: null};
  for (let i=0;i<9;i++) {
    if (!b[i]) {
      b[i] = isMaximizing ? "O" : "X";
      let score = minimax(b, !isMaximizing).score;
      b[i] = null;
      if (isMaximizing ? score > best.score : score < best.score)
        best = {score, index:i};
    }
  }
  return best;
}

function monteCarloSim(b, move, trials=200) {
  let wins=0, draws=0, losses=0;
  for (let t=0;t<trials;t++) {
    let sim = clone(b);
    sim[move] = "O";
    let turn = "X";
    while (!checkWinner(sim)) {
      let avail = sim.map((v,i)=>v?null:i).filter(x=>x!==null);
      if (!avail.length) break;
      sim[avail[Math.floor(Math.random()*avail.length)]] = turn;
      turn = turn==="X"?"O":"X";
    }
    let res = checkWinner(sim);
    if (res==="O") wins++;
    else if (res==="X") losses++;
    else draws++;
  }
  return (wins - losses) + draws*0.1;
}

function aiMove() {
  let bestScore=-Infinity, move=null;
  for (let i=0;i<9;i++) {
    if (!board[i]) {
      let temp = clone(board);
      temp[i] = "O";

      // Evaluate with multiple strategies
      let miniScore = minimax(temp,false).score;
      let simScore = monteCarloSim(board,i);
      let key = boardKey(temp);
      let mem = aiMemory[key] || {wins:0, losses:0, draws:0};
      let pastScore = mem.wins*5 - mem.losses*7 - mem.draws*2;

      let totalScore = miniScore + simScore + pastScore*0.5;

      if (totalScore > bestScore) {
        bestScore = totalScore;
        move = i;
      }
    }
  }

  if (move!==null) {
    board[move] = "O";
    render();
    let result = checkWinner(board);
    if (result) endGame(result);
  }
}

// UI
function render() {
  boardEl.innerHTML = "";
  board.forEach((cell, i) => {
    const div = document.createElement("div");
    div.className = "cell";
    div.textContent = cell || "";
    div.onclick = () => {
      if (!cell && !gameOver) {
        board[i] = "X";
        render();
        let result = checkWinner(board);
        if (result) return endGame(result);
        aiMove();
      }
    };
    boardEl.appendChild(div);
  });
}

let history = [];
function endGame(result) {
  gameOver = true;
  statusEl.textContent = result === "draw" ? "Draw!" : `${result} wins!`;
  storeGameResult(history.concat(boardKey(board)), result);
  setTimeout(() => {
    board = Array(9).fill(null);
    gameOver = false;
    history = [];
    render();
    statusEl.textContent = "New game started.";
  }, 2000);
}

render();
</script>
</body>
</html>
