<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tictact-AI — Expectimax with Human Move Probabilities</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0b0b0b;--panel:#111;--accent:#0f9;--muted:#999;--white:#eee}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--white); margin:0; padding:20px; -webkit-font-smoothing:antialiased}
  h1{margin:0 0 8px;font-weight:600}
  .wrap{display:flex;gap:18px;flex-wrap:wrap}
  .board{display:grid;grid-template:repeat(3,120px)/repeat(3,120px); gap:8px; background:transparent}
  .cell{background:#0e0e0e;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:48px;cursor:pointer; user-select:none; box-shadow:0 4px 10px rgba(0,0,0,.6);}
  .cell.disabled{cursor:not-allowed; opacity:.6}
  .panel{background:var(--panel); padding:12px; border-radius:10px; min-width:320px; max-width:540px}
  .info{font-size:14px;color:var(--muted); margin-bottom:8px}
  .small{font-size:13px;color:var(--muted)}
  button{background:#111;border:1px solid #222;color:var(--white);padding:8px 12px;border-radius:8px;cursor:pointer}
  .topline{display:flex;gap:12px;align-items:center;justify-content:space-between}
  .grid-wrap{display:flex;gap:16px;align-items:flex-start}
  .highlight{outline:3px solid rgba(15,153,85,.18); box-shadow:0 6px 20px rgba(0,0,0,.6)}
  .list{max-height:420px;overflow:auto;padding:6px 0}
  .seq{padding:8px;border-radius:8px;margin-bottom:8px;background:#0c0c0c}
  .muted{color:var(--muted)}
  .stats{display:flex;gap:12px;margin-top:8px}
  .stat{background:#0c0c0c;padding:8px;border-radius:8px; min-width:84px; text-align:center}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media (max-width:920px){
    .board{grid-template:repeat(3,90px)/repeat(3,90px)}
    .cell{font-size:36px}
    .wrap{flex-direction:column}
  }
</style>
</head>
<body>
  <div class="topline">
    <div>
      <h1>Tictact-AI</h1>
      <div class="info">You are X and always go first. AI is O. After your move the AI evaluates all possible future games using a probabilistic model of human moves and chooses the move that maximizes its expected chance to win.</div>
    </div>
    <div>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <div class="wrap">
    <div class="grid-wrap">
      <div>
        <div id="board" class="board" aria-label="TicTacToe board"></div>
        <div class="small muted" style="margin-top:8px">Click an empty square to play X. The AI will respond automatically.</div>
      </div>

      <div class="panel">
        <div><strong>AI decision</strong></div>
        <div id="aiDecision" class="small muted" style="margin-top:6px">Waiting for your first move...</div>

        <div class="stats" id="stats" style="display:none">
          <div class="stat"><div class="muted">P(O wins)</div><div id="pO" style="font-weight:600">—</div></div>
          <div class="stat"><div class="muted">P(X wins)</div><div id="pX" style="font-weight:600">—</div></div>
          <div class="stat"><div class="muted">P(Draw)</div><div id="pD" style="font-weight:600">—</div></div>
        </div>

        <hr style="border:none;height:1px;background:#0b0b0b;margin:12px 0;border-radius:2px" />

        <div><strong>Top likely future games (after AI move)</strong></div>
        <div class="small muted" style="margin:6px 0 12px">Sequences show moves (pos 0-8), probability, and outcome. Higher probability paths are human-like according to a simple human model.</div>
        <div id="sequences" class="list"></div>
        <div class="footer">Model notes: the human-move probabilities prefer immediate wins > blocking > forks > center > corners > edges. The AI assumes future humans behave according to that distribution.</div>
      </div>
    </div>
  </div>

<script>
/***************
 * Game & AI code
 ***************/

const WIN_LINES = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

const boardEl = document.getElementById('board');
const aiDecisionEl = document.getElementById('aiDecision');
const sequencesEl = document.getElementById('sequences');
const statsEl = document.getElementById('stats');
const pOel = document.getElementById('pO');
const pXel = document.getElementById('pX');
const pDel = document.getElementById('pD');
const restartBtn = document.getElementById('restartBtn');

let board = Array(9).fill(null); // null | 'X' | 'O'
let gameOver = false;

function createBoardUI(){
  boardEl.innerHTML = '';
  for(let i=0;i<9;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.dataset.index = i;
    c.addEventListener('click', ()=> humanMove(i));
    boardEl.appendChild(c);
  }
  renderBoard();
}

function renderBoard(){
  for(let i=0;i<9;i++){
    const el = boardEl.children[i];
    el.textContent = board[i] || '';
    el.classList.toggle('disabled', !!board[i] || gameOver);
    el.classList.remove('highlight');
  }
}

function checkWinner(b){
  for(const line of WIN_LINES){
    const [a,b1,c] = line;
    if(b[a] && b[a] === b[b1] && b[a] === b[c]) return b[a];
  }
  if(b.every(Boolean)) return 'draw';
  return null;
}

function getAvailableMoves(b){
  const arr=[];
  for(let i=0;i<9;i++) if(!b[i]) arr.push(i);
  return arr;
}

/* Heuristic for human move preference:
  - immediate win (very high)
  - block opponent immediate win (high)
  - create fork (mid)
  - block opponent fork (mid)
  - center (3)
  - corner (2)
  - edge (1)
*/
function scoreHumanMove(originalBoard, move){
  // returns a positive numeric score
  const b = originalBoard.slice();
  b[move] = 'X';

  // immediate win?
  if(checkWinner(b) === 'X') return 1000;

  // would this block an opponent immediate win? simulate O winning next
  const opp = 'O';
  const avail = getAvailableMoves(originalBoard);
  let blocksImmediate = false;
  for(const m of avail){
    if(m === move) continue;
    const bb = originalBoard.slice();
    bb[m] = opp;
    if(checkWinner(bb) === opp){
      // If human move prevents that by playing in m, then it's blocking
      if(move === m) { blocksImmediate = true; break; }
    }
  }
  // simpler blocking: if opponent had an immediate winning move and human plays on it
  const opponentImmediate = avail.filter(m=>{
    const bb = originalBoard.slice(); bb[m] = opp; return checkWinner(bb) === opp;
  });
  if(opponentImmediate.includes(move)) return 800;

  // fork detection (human creating two threats)
  function countWinningThreats(boardState, player){
    let threats=0;
    for(const m of getAvailableMoves(boardState)){
      const b2 = boardState.slice(); b2[m] = player;
      if(checkWinner(b2) === player) threats++;
    }
    return threats;
  }
  if(countWinningThreats(b,'X') >= 2) return 450;

  // block opponent fork
  const afterOppForks = getAvailableMoves(originalBoard).some(m=>{
    const bb = originalBoard.slice(); bb[m] = 'O';
    return countWinningThreats(bb,'O') >= 2;
  });
  // if human move blocks some fork possibility, give some score
  if(afterOppForks && countWinningThreats(b,'O') < 2) return 350;

  // center
  if(move === 4) return 120;
  // corners
  if([0,2,6,8].includes(move)) return 80;
  // edges
  return 40;
}

// softmax convert scores to probabilities (temperature controls spread)
function softmax(values, temperature=1.0){
  const max = Math.max(...values);
  const exps = values.map(v => Math.exp((v - max) / temperature));
  const sum = exps.reduce((a,b)=>a+b,0);
  return exps.map(e => e / sum);
}

/*
 * Expectimax-style evaluator:
 * - At human (X) nodes we treat their move as probabilistic according to the heuristic (softmax).
 * - At AI (O) nodes the AI picks the move that maximizes its expected P(O wins).
 *
 * We return an object: {pO:..., pX:..., pD:...}
 */
function evaluateExpectimax(boardState, turn){
  const winner = checkWinner(boardState);
  if(winner){
    return {
      pO: winner === 'O' ? 1 : 0,
      pX: winner === 'X' ? 1 : 0,
      pD: winner === 'draw' ? 1 : 0
    };
  }

  const avail = getAvailableMoves(boardState);
  if(turn === 'X'){
    // compute heuristic scores and probabilities
    const scores = avail.map(m => scoreHumanMove(boardState, m));
    const probs = softmax(scores, 1.0);
    // expectation over human moves
    let agg = {pO:0, pX:0, pD:0};
    for(let i=0;i<avail.length;i++){
      const mv = avail[i];
      const prob = probs[i];
      const next = boardState.slice(); next[mv] = 'X';
      const e = evaluateExpectimax(next, 'O');
      agg.pO += prob * e.pO;
      agg.pX += prob * e.pX;
      agg.pD += prob * e.pD;
    }
    return agg;
  } else {
    // AI chooses the move that maximizes pO (its win chance)
    let best = null;
    for(const mv of avail){
      const next = boardState.slice(); next[mv] = 'O';
      const e = evaluateExpectimax(next, 'X');
      if(!best || e.pO > best.val){
        best = {move:mv, val:e.pO, eval:e};
      }
    }
    return best.eval;
  }
}

/*
 * After AI chooses its immediate move, enumerate all possible *future* game leaf paths
 * considering the human's probabilistic choices and AI's deterministic picks.
 *
 * We'll only follow the AI's chosen moves at AI nodes (because that's what AI will do).
 * For human nodes we expand all moves and weight by the human probability model.
 *
 * This function returns an array of {sequence: [{turn:'X'|'O',pos:int}, ...], prob, result}
 */
function enumerateLeafPaths_afterAIChosen(boardState, turn){
  const result = [];
  function recurse(b, t, path, prob){
    const w = checkWinner(b);
    if(w){
      result.push({sequence: path.slice(), prob:prob, result:w});
      return;
    }
    const avail = getAvailableMoves(b);
    if(t === 'X'){
      // human probabilities
      const scores = avail.map(m => scoreHumanMove(b, m));
      const probs = softmax(scores, 1.0);
      for(let i=0;i<avail.length;i++){
        const mv = avail[i];
        const p = probs[i];
        const next = b.slice(); next[mv] = 'X';
        path.push({turn:'X',pos:mv});
        recurse(next, 'O', path, prob * p);
        path.pop();
      }
    } else {
      // AI chooses best deterministic move (same logic as evaluateExpectimax)
      let bestMove = null;
      let bestVal = -1;
      for(const mv of avail){
        const next = b.slice(); next[mv] = 'O';
        const e = evaluateExpectimax(next, 'X');
        if(e.pO > bestVal){ bestVal = e.pO; bestMove = mv; }
      }
      // follow that best move
      const next = b.slice(); next[bestMove] = 'O';
      path.push({turn:'O',pos:bestMove});
      recurse(next, 'X', path, prob);
      path.pop();
    }
  }
  recurse(boardState.slice(), turn, [], 1.0);
  return result;
}

/*
 * Top-level: after the human has played, the AI evaluates each candidate AI move (O's moves)
 * simulating that after each AI move the future human moves are probabilistic.
 * It picks the AI move that maximizes pO (AI win probability).
 */
function aiChooseMoveAndAnalyze(currentBoard){
  const avail = getAvailableMoves(currentBoard);
  if(avail.length === 0) return null;
  let best = null;
  const moveChoices = [];
  for(const mv of avail){
    const next = currentBoard.slice(); next[mv] = 'O';
    const evalRes = evaluateExpectimax(next, 'X');
    moveChoices.push({move:mv, eval: evalRes});
    if(!best || evalRes.pO > best.eval.pO) best = {move:mv, eval:evalRes};
  }
  // best now contains the move ai will play (to maximize pO)
  return {best, choices:moveChoices};
}

/*********************************
 * UI & game loop logic
 *********************************/

function humanMove(i){
  if(gameOver) return;
  if(board[i]) return;
  // human plays X
  board[i] = 'X';
  renderBoard();
  const winner = checkWinner(board);
  if(winner){
    finalizeGame(winner);
    return;
  }
  // AI step: evaluate and choose
  aiDecisionEl.textContent = 'AI is computing...';
  // small delay so UI updates to show human move before heavy compute:
  setTimeout(()=>{
    const analysis = aiChooseMoveAndAnalyze(board);
    if(!analysis){
      finalizeGame(checkWinner(board) || 'draw');
      return;
    }
    const aiMove = analysis.best.move;
    // Show decision summary
    aiDecisionEl.innerHTML = `AI chooses position <strong>${aiMove}</strong> (evaluated P(O wins) = <strong>${(analysis.best.eval.pO*100).toFixed(1)}%</strong>).`;
    statsEl.style.display = 'flex';
    pOel.textContent = (analysis.best.eval.pO*100).toFixed(1) + '%';
    pXel.textContent = (analysis.best.eval.pX*100).toFixed(1) + '%';
    pDel.textContent = (analysis.best.eval.pD*100).toFixed(1) + '%';

    // AI actually plays the chosen move
    board[aiMove] = 'O';
    // visually highlight AI move
    renderBoard();
    boardEl.children[aiMove].classList.add('highlight');

    // Now enumerate likely future games (after the AI move), list top sequences
    const enumerated = enumerateLeafPaths_afterAIChosen(board, 'X');
    // sort by probability desc and show top 12
    enumerated.sort((a,b)=>b.prob - a.prob);
    showSequences(enumerated.slice(0, 12));

    const w2 = checkWinner(board);
    if(w2) finalizeGame(w2);
  }, 20);
}

function showSequences(seqList){
  sequencesEl.innerHTML = '';
  if(seqList.length === 0){
    sequencesEl.innerHTML = '<div class="muted">No future sequences (game ended).</div>';
    return;
  }
  for(const s of seqList){
    const div = document.createElement('div');
    div.className = 'seq';
    const moves = s.sequence.map(it => `${it.turn}@${it.pos}`).join(' → ');
    const pr = (s.prob*100).toFixed(2) + '%';
    const outcome = s.result === 'draw' ? 'Draw' : (s.result === 'X' ? 'X wins' : 'O wins');
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="font-family:monospace">${moves || '(no moves)'}</div><div style="text-align:right"><div class="small muted">${pr}</div><div style="font-weight:600">${outcome}</div></div></div>`;
    sequencesEl.appendChild(div);
  }
}

function finalizeGame(winner){
  gameOver = true;
  renderBoard();
  if(winner === 'draw'){
    aiDecisionEl.innerHTML = `<strong>Game over — Draw</strong>`;
  } else {
    aiDecisionEl.innerHTML = `<strong>Game over — ${winner} wins</strong>`;
  }
  // reveal full final leaf list (optional): enumerate from this finished board returns single terminal path
  const enumerated = enumerateLeafPaths_afterAIChosen(board, 'X');
  showSequences(enumerated.slice(0,12));
}

function restart(){
  board = Array(9).fill(null);
  gameOver = false;
  aiDecisionEl.textContent = 'Waiting for your first move...';
  sequencesEl.innerHTML = '';
  statsEl.style.display = 'none';
  createBoardUI();
}

restartBtn.addEventListener('click', restart);

// init
createBoardUI();

</script>
</body>
</html>
